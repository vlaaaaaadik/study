							11.09
ООП - це розширення структурного програмування якому основними концепцыями э поняття класів і обєктів
Класи в С++ - це абстракція описує методи та властивості ще неіснуючих обєктів
Обєкти - це конкретне уявлення абстракції що має свої властивості і методи
Створені обєкти на основі одного класу називаються екземплярами цього класу
ці обєкти можуть мати різну поведінку властивості але все одно будуть обєктами одного класу
в ООП існують три основні принципи побудови класів
Інкапсуляція - це властивість що дозволяє обєднати в класі дані і методи що працюють з ними і приховати деталі реалізації від користувача
Наслідування - це властивість що дозволяє створити новий клас нащадок на основі існуючого, при цьому всі х-ки батька присвоюються нащадку
Поліморфізм - властивість класів що дозволяє використовувати обєкти класів з однаковим інтерфейсом без інформації про тип і внутрішню структуру обєктів
				Конструктори деструктори
class Stack
{
	char stck[5];
	int tos;
public:
	Stack() : tos(0) {}; // конструктор
	//void init();
	void push(char ch);
	char pop();
	~Stack() {}; // деструктор
};
					обєкти як аргументи
					статичні поля класу
якщо поле класу оголошується з ключовим словом static то значення цього поля буде одинаковим для всіх обєктів даного класу
					Константні методи
Вони не змінюють значення полів свого класу 
					Константні аргументи методів
якшо хочете передати аргумент у Метод через посилання і в той же час захистити його від зміни то треба зробити цей аргумент const
					константні обєкти 
для константних обєктів викликаємо константні методи
					оператори динамічного розподілу памяті new, delete;
змінна-покажчик = new тип_змінної
delete змінна-покажчик
оператор new виділяє область памяті достатню для зберігання значення заданого типу і повертає покажчик на цю область памяті.
Він дає змогу динамічно виділяти память
delete звільняє область памяті на яку вказує даний покажчик.
														дружні функції
в С++ існує можливість доступу до закритих членів класу через окрему функцію
для цього достатньо оголосити ці функції дружніми
class someClass
{
	public:
	friend void frnd(someClass obj);
}
void frnd(someClass obj)
friend надає функції яка не є членом класу доступ до його закритих членів.
									аргументи функції за замовчуванням.
#include "stdafx.h"
#include <iostream>
#include <cstdlib>
#include <conio.h>

using namespace std;

void Sumbols(char = '$', int = 5);

int main()
{
	Sumbols();
	Sumbols('%', 100);
	_getch();
    return 0;
}

void Sumbols(char i, int count)
{
	for (int j = 0; j < count; j++)
	{
		cout << i;
	}
}
//неоднозначність
float f(float i)
{
	return i/2.0;
}
double f(double i)
{
	return i/3.0;
}

int main()
{
	f(10); // неоднозначність через те,що не зрозуміло в що перетворити в float чи double
}
// неоднозначність
void f1(unsigned char c)
{
	cout<<c<<endl;
}
void f1(char c)
{
	cout<<c<<endl;
}
int main()
{
	f1(88); // неоднозначність куди в unsigned char чи в char
}
//неоднозначність
int f3(int a)
{
	return a*a;
}
int f3(int a, int b = 0)
{
	return a*b;
}

{
	f3(88); // неоднозначність куди в (int) чи в (int,int)
}
								перегрузка операторів
не можна змінювати приорітет, не можна змінювати кількість перандів у оператора, не можна створювати новий оператор,
