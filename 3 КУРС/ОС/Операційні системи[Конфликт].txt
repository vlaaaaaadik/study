                                           ФАЙЛОВІ СИСТЕМИ 5.09
Частина ОС за допомогою якої забезпечується робота з файлами і з збереженням даних на зовнішніх пристроях.
Принцип організації файлової системи залежить від ОС.
Основні технологічні принципи windows
plug&play - це автоматичне розпізнавання і налагодження пристроїв компютера.
Object link and embedding (OLE) - звязок вбудовування обэктів це забезпечення розташування, вбудування або звязування документа
з документом що створений за допомогою будь-якої іншої програми windows при цьому зберігається можливість змінювати і редагувати документ або обєкт
drag & drop - метод фізичного і логічного переміщення обєктів що використовується для переміщення обєктів або копіювання в інше положення.
what you see is what you get (wysiwyg) зображення документа на екрані при його перегляді і редагуванні і зображення на листку майже однакове

файлова система FAT (таблиця розміщення файлів) - цей термін відноситься до лінійної табличної структури з відомостями про файли:
імена файлів, атрибути та інші дані за допомогою яких визначається місцезнаходження файлів або їх фрагментів у FAT.
елемент фат визначає фактичну область диска в якій зберігається початок фізичного файлу.
Логічний дисковий простір поділяється на дві області 1. системна область 2. область даних
1. створюється при форматуванні і поновлюється при маніпулюванні файловою структурою.
Область даних містить файли і каталоги які підпорядковані кореневому каталогу і доступна через користувацький інтерфейс.
Системна область складається з таких компонентів:
- завантажуваний запис
- зарезервовані сектори
- таблиця розташування файлів (FAT)
- кореневий каталог
{Кластер це мінімальна неподільна частина файлу.}
таблиця розташування файлів являє собою карту (образ) в якій описано стан кожної ділянки області даних.
Область даних розбита на кластери.
В таблиці FAT кластери які належать одному файлу ( некореневого каталогу ) звязані в ланцюги.
Для вказування номера кластеру в системі управління файлами вказується слово (16 ,32 , 64 біт)
FAT використовуєтсья при доступі до диску дуже інтенсивно.
він завантажується в оперативну память. 
Кореневий каталог(root directory) відрізняється від іншого тим що він розташований в фіксованому місці на диску і має фіксовану к-сть елементів.
Структура кореневого каталогу :
1. імя файлу або каталогу (11 байт)
2. атрибути файлу (1 байт)
3. резервне поле (1 байт )
4. час створення (3 байта)
5. дата створення (2 байта)
6. дата останнього доступу (2 байта)
7. зарезервовано (2 байта)
8. час останньої модифікації (12:09 17.09.201812:09 17.09.20182 байта)
9. номер початкового кластера у FAT (2 байта)
10. розмір файлу (4 байта)
FAT32 є більш вдосконаленою системою за FAT ефективніше використовується дисковий простір за рахунок використання кластерів меншого розміру
це призводить до економії дискового простору але недолік це збільшення системної області за рахунок збільшення кількості ланцюгів між кластерами
в FAT32 можна переміщувати кореневий каталог і використовувати резервну копію замість стандартної.
Завантажувальний запис у FAT32 дозволяє створити копії критичних структур даних що підвищує стійкість та надійність дисків.
Кореневий каталог являє собою звичайний ланцюг кластерів тому може знаходитись в будь-якому місці диска і це знімає обмеження на розмір кореневого каталогу.
це дозволяє записувати нескінченну кількість файлів на диск (єдине обмеження - фізичний розмір памяті диску)

Файлова система NTFS (New Tecnology File System) - система містить велику к-сть значних вдосконаленнь що суттєво відрізняє її від інших.
Файли зберігаються в каталогах але робота з дисками великого обєму відбувається набагато ефективніше:
- Є засоби для обмеження доступу до файлів і каталогів
- Уведено механізми які суттєво підвищують надійність файлової системи
- Зняті обмеження на максимальну к-сть дискових секторів або кластерів
Основні характеристики NTFS:
Надійність. Високошвидкісні компютери повинні бути надійними для цього введено механізм транзакцій
транзакція це набір команд або операцій які повинні виконатись від першої команди до останньої при цьому ведеться журналювання
файлових операцій ( всі команди кожної транзакції протоколюються і здійснюються тільки у випадку їх 100% коректності.)
Якщо команда транзакції не коректна то за допомогою журналу уже виконаних команд операційна система повертається до початкового стану (початок транзакції) відкат.
розширена функціональність:
-вдосконалена відмовостійкість
-емуляція інших файлових систем
-потужна модель захисту
-паралельне опрацювання потоків даних
-створення файлових атрибутів користувачем
підтримка стандарту POSIX. до числа базових засобів відноситься необовязкове використання імен файлів з врахуванням регістра,
збереження часу останнього звернення до файлу, механізм альтернативних імен який дозволяє посилатися на один і той же файл з використанням
різних імен.
Гнучкість. Розмір кластера може змінюватись від 512 байт до 64 Кбайт. 
NTFS добре працює з великими масивами даних та великими томами. Максимальний розмір тому або файлу може бути 16 Ебайт
16 Ебайт = 16 тисяч мільярдів гігабайт.
Кількість файлів необмежена тому що в основу структури каталогів NTFS покладено бінарне дерево.
Пошук файлів не повязаний з лінійною залежністю і з їх кількістю. 
В NTFS є засоби самовідновлення і підтримки різних механізмів перевірки цілісності системи.
NTFS підтримує обєктну модель захисту. Тома каталоги файли це є самостійні обєкти NTFS.
параметри доступу до них залежать від облікового запису користувача.
У NTFS є вбудовані засоби стиснення.
Файл з іменем myfile.txt розміщується з 8 кластера. всього він займає 12 кластерів. ланцюг кластерів chain може бути записаний 
в такий спосіб :
...
Кластер з номером 18 позначений кодом F7 це є поганий кластер він не може бути використаний для розміщення даних.
при форматуванні перевіряється поверхня диску і ті сектори в при контрольному читанні в яких відбуваються помилки позначають f7
кластер 1D позначений FF це останній кластер ланцюга що належить даному файлу.
вільні позначаються 00. При виділенні нового кластера береться перший вільний кластер.
файли на диску переміщуються збільшуються зменшуються і це призводить до фрагментації файлів - дані файлу можуть розміщуватися в несуміжних кластерах
це призводить до уповільнення роботи з файлом.
				ЕАПИ ЗАВАНТАЖЕННЯ ОС 7.09
1. Вмикання живлення
блок живлення здійснює перевірку електричних параметрів компютера. якщо вони в нормі то передається сигнал Power good
процесору. час між вмиканням живлення і передавання сигналу від 1 до 0.5 сек.
2. в таймер мікропроцесора поступає сигнал power good. з отриманням цього сигналу таймер перестає посилати сигнал reset процесору.
відбувається вмикання процесору
3. Виконання коду ROM BIOS процесором . Процесор завантажує ROM BIOS починаючи з адресів FFFF 0000
4. Виконання початкового тестування пристроїв. Кожна помилка яка зустрічається повідомляється певними звуковими кодами тому що
відеосистема ще не 
5. за допомогою BIOS здійснюється пошук адаптерів для яких потрібне завантаження власного BIOS. Типовим прикладом є відеокарта.
процедура завантаження починається з сканування памяті з адреси C000 0000 - > C780 0000 для пошуку відео ROM. Таким чином завантажується
система всіх адаптерів
6. ROM BIOS перевіряє чи це вмикання чи це перезавантаження. Якщо за адресою 0000 0472 число відмінне від 1234 то це перезавантаження
7. Якщо це включення то за допомогою ROM відбувається запуск повного POST (power on self test). Якщо перезавантаження то він відключається.
POST ділиться на 3 компоненти:
- за допомогою відеотесту ініціалізується відеоадаптер, тестується і відеопамять.
- при ідентифікації BIOS визначається версія прошивки, виробник і дата вироблення BIOS.
- за допомогою тесту памяті перевіряється память і визначається розмір.
Якщо при перевірці виникають несуттєві помилки то вони відображаються на екрані але продовжується завантаження. якщо суттєві 
то процес завантаження припиняється і супроводжується серією біб кодів.
8. зчитування відомостей з CMOS. це э невелика область памяті від 64 байт живиться від батарейки на материнці.
9. якщо першим пристроєм є HDD то BIOS перевіряє перший сектор диска адреса 001 Master Boot Record 
				Аналіз продуктивності систем памяті 17.09
див ієрархія памяті
Мірами виміру продуктивності систем памяті є % попадань(hitrate) і % промахів (missrate) середній час доступу.

missrate = misses/total memory access

hitrate = hits/total memory access

		приклад: програма має 2000 команд звернень до даних завантаження і збереження і тільки 1250 з цих команд знайшли необхдні дані в кеші
		750 командам прийшлося отримувати дані з ОП або з диску.
	missrate = 750/2000=0.375
	hitrate = 1250 / 2000 = 0.625
середній час доступу(AMAT) - це середній час який процесор витрачає чекаючи доступу до памяті при виконанні команд завантаження load та збереження даних store
В типовій компютерній системі процесор спочатку шукає дані в кеші якщо даних в кещі немає він переходить до ОП якщо і там нема то в віртуальній памяті на диску
АМАТ = tcache + MRcache (tmm+MRmm*tvm)
tcache tmm i tvm - це час доступу до кешу, оперативної і диску
MRcache i MRmm - це % промахів кешу та ОП
приклад обрахунку АМАТ : якщо у нас є два рівня ієрархії памяті це кеш і ОП чому = АМАТ
Кеш 	1		10%
ОП 		100		0%
АМАТ=1+0,1(100) = 11 тактів
це означає що процесор витрачає 10 тактів на очікування даних на кожний такт реального використання цих даних
наступний приклад: який процент промахів потрібний для зменшення середнього часу доступу до памяті до 1.5 такта
якщо процент промахів до кешу m тоді середній час доступу = 1 + 100m 
m=2.5/100=0.5%
покращення продуктивності в реалі може бути не таким ефектним як в теорії
наприклад: збільшення швидкості памяті в 10 раз не обовязково зробить комп в 10 раз швидшим.
Якщо 50 % команд в програмі це команди завантаження та збереження даних то збільшення швидкості памяті в 10 раз приведе збільшення продуктивності в 1,82 рази 
														кеш память 19.09
фізично кеш память знаходиться на кристалі процесора
Кеш вміщує в себе дані які часто використовуються
кількість слів даних які може зберігати кеш назив ємністю кеша
так як ємність кеша менша за ємність ОП то розробних компютерної системи повинен вирішити яка підмножина ОП повинна зберігатися в кеші
Коли процесор хоче отримати доступ до даних він спочатку шукає їх в кеші якщо дані там є то виникло попадання в кеш і процесор отримує їх моментально
якщо їх немає то виник промах кешу і процесор читає дані з оперативної памяті і поміщає їх в кеш для наступного використання.
Для цього кеш повинен замінити старі дані на нові 
кеш характеризується такими параметрами :
capacity - ємність 
set - число наборів
block - довжина рядка
	ідеальний кеш повинен вгадати які дані потрібні процесору і вибрати їх з ОП раніше таким чином щоб кеш мав 0% промахів
так як вгадати не можливо то кеш повинен вгадати які дані потрібні будуть базуючись на попередніх зверненнях до памяті 
кеш використовує часову та просторову локальність для того щоб зменшити % промахів в кеші.
	Часова локальність означає що процесор вірогідно ще раз звернеться до тих даних які він недавно використовував.
Тому коли процесор читає або записує дані не в кеші то ці дані записуються в кеш і наступні звернення не викличуть промаха кеша.
	просторова локальність - означає що коли процесор звертається до якихось даних то вірогідно йому потрібні будуть дані які розмішені поряд.
Тому кеш читає одне слово даних памяті
ця група слів називається cache line або cache block
число слів в рядку - довжина рядка 
принцип просторового або локальності даних було підтверджено на практиці 
приклади:
якщо змінна використовується в програмі то вона буде використовуватись ще раз
якщо використовується якийсь елемент масиву то вірогідно що другі елементи масиву теж будуть використовуватись
	як знайти дані в Кеші?
Кеш складається з S наборів кожний з яких складається з кількох рядків (блоків даних)
взаємозвязок між даними розміщеними в ОП і в Кеші називається відображенням.
Кожний адрес памяті відображається в один і той самий набір кеша.
Кілька біт адресу використовується щоб визначити який набір набір кешу включає пошукові дані.
		класифікація кеш памяті
1. кеш прямого відображення (direct maped cache)
кожний набір має тільки один набор або блок S=B
кожен адрес оперативної памяті відображається на один рядок кешу
2. Наборно-асоціативний кеш (N-way set asociative cache)
3. повністю асоціативний кеш (fully asociative cache)
									кеш прямого відображення
див кеш прямого відображення.png
Кожний набір включає тільки один набор даних S=B 
оперативна память поділена на блоки по B слів а кеш на рядки по B слів
адрес одного слова який знаходиться у блоці 0 ОП відображається в 0 набір кеша
адрес слова з блока 1 на 1 кеша і тд. поки адрес адрес слова з блока B-1 ОП не відобразиться в B-1 кеша
більше рядків у кеші немає та наступний блок ОП B знову відображається в 0 кеша
на рисунку кеш ємнісю в 8 слів і розміром рядка в одне слово.
в кеші 8 наборів кожний з яких має один рядок. довжина рядка = 1 слову. 
Молодші два біта адреси = 0 завжди тому що всі адреси вирівняні на границю слова.
наступні трембіта адресують один з восьми наборів в який буде відображатись цей адрес памяті.
Дані з адрес 00000004 00000024 ... FFFFFFE4 ці адреси будуть відображатись в один і той самий набір в кеші тому що 3 4 5 біт є одинаковий.
В який набір кеша буде відображатися адрес з номером 14 у 16 системі
відповідь адреса буде поміщена в блок під номером 5
слова з адресами 34, 54 ,74 теж будуть відображатись в один набір
в один набір кеша відображається багато адресів. Кеш повинен відслідковувати адреси даних що знаходяться в кожному з наборів в текучий момент часу.
Молодші біти адреси визначають в якому блоці знаходяться дані. Біти що залишилися називаються тегом і вказують який власне з адресів знаходиться в цьому наборі
							апаратна реалізація кешпамяті прямого відображення 24.09
див Апаратна реалізація кеш.png
там компаратор
кеш складається з 32 біта даних + 27 кеша + 1
V - біт достовірності
Кожна комірка включає в себе 32 біта даних + 27 тега +1 біт достовірності
до кешу звертаються використовуючи 32 біта адресу
два молодших біта ігноруються.
команда завантаження читає цю комірку з кеш памяті і провіряє тег і біт достовірності.
якщо тег з адресу і з комірки співпадає і біт достовірності = 1 то виконується попадання в кеш і дані передаються процесору в іншому випадку стається промах кешу і
підсистема памяті повинна прочитати дані з ОП
													ВІРТУАЛЬНА ПАМЯТЬ
у більшості сучасних систем в якості нижнього рівня ієрархії памяті використовується HDD або SSD.
SSD Solid State disc;
оперативна память швидкодіюча але дорога і малий розмір має а HDD має великий об`єм але повільний.
Тому якщо програма має багато звернень до зовнішнього диску то продуктивність суттєво знижується
Ціллю включення зовнішнього диску в ієрархію памяті - за недорого створити видимість памяті великого обєму одночасно забезпечуючи для більшості звернень до памяті
швидкість доступу що = швидкості звернень до ОП наприклад компи з оперативною памятю 128 мб може забезпечувати видимість наявності 2 гб ОП використовуючи для цього зовнішній диск
в цьому випадку 2 гб це віртуальна память а 128 мб назив фізичною ОП.
Програми можуть звертатися до даних до будь-якого місця віртуальної памяті тому вони повинні використовувати віртуальні адреса
Віртуальні адреса визначають розміщення даних у віртуальній памяті.
ОП зберігає останні записані з віртуальної памяті блоки даних тому фізична память виступає в ролі кешп для віртуальної памяті.
більшість звернень виконується до оперативної памяті але в той же час програма має доступ до великого обєму віртуальної памяті.
Відповідність термінів кеша і віртуальної памяті....
див віртуальні та фізичні сторінки.png
віртуальна память ділиться на віртуальні сторінки
ОП також розділена на сторінки також такого самого розміру.
Віртуальна сторінка може розміщуватися або в ОП або на Жорсткому диску.
Процес перетвореня віртуального адресу в фізичний називається трансляцією адресу.
Якщо процесор звертається до віртуального адресу якого немає в ОП виникає сторінкова помилка Page fault і тоді ОС запускає Відповідну сторінку з жосткого диску
шоб таких помилок не було будь-яка віртуальна сторінка може відображатися на будь-яку фізичну сторінку
фізична сторінка працює так само як кеш для віртуальної памяті.
Для того шоб провірити в кеші використовується компаратор для звірки адресів. Для віртуальної памяті компаратор не раціонально використовувати
у системах Віртуальної памяті використовується трансляція адресів за допомогою таблиці сторінок page table .
Таблиця сторінок включає в себе запис для кожної віртуальної сторінки ці записи вказують на її розміщення в ОП або на зовніщньому диску.
якщо сторінка займає 4 кб а маємо місце 10 мб то записів в таблиці сторінок = 2500
Кожна команда завантаження і збереження вимагає доступу до таблиці сторінок з наступним доступом до ОП. 
Звернення до таблиці сторінок дозволяє транслювати віртуальний адрес у фізичний.
Тільки фізичний адрес використовується для читання та запису даних.
Таблиця сторінок знаходиться в ОП.
Кожна команда завантаження або збереження включає в себе два звернення до оперативної памяті 
1. звернення до таблиці сторінок 
2. звернення до самих даних.
Для збільшення продуктивності роботи (прискорити трансляцію адреса) використовується буфер асоціативної трансляції TLB
Translation lookaside buffer.
ТЛБ включає в себе найбільш використовувані записи
				Фізичні та віртуальні сторінки (віртуальна память 2 гб і ОП 128 мб)
ДИВ фізична та віртуальна память.jpg
ДИВ 128 mb ram -2gb virtual.jpg
трансляція віртуального адресу в фізичний 
див трансляція віртуального адресу в фізичний.jpg
Молодші 12 біт відображають змішення від початку сторінки і не потребують трансляції.
старші 19 біт віртуального адресу визначають номер віртуальної сторінки і транслюються в 15 бітний номер фіз сторінки (PPN)
							Трансляція адреси за допомогою таблиці сторінок
ДИВ трансляція віртуальної адреси за допомогою таблиці сторінок.jpg
для того щоб виконати операцію завантаження або збереження даних процесор спочатку повинен транслювати віртуальний адрес в фізичний а після звернутися до ОП
використовуючи фізичний адрес.
Процесор вибирає номер сторінки з віртуального адресу у нашому випадку це 2 і добаваляє його до вмістимого регістра таблиці сторінок для того щоб знайти фізичний адрес відповідного
запису таблиці сторінок.
якщо запис дійсна а біт достовірності = 1 V = 1 то процесор обєднує номер фізичної сторінки і змішення і отримує фізичний адрес.
Процесор читає та записує дані використовуючи цей адрес.
Так як таблиця сторінок зберігається в ОП то кожна команда завантаження або збереження потребує два звернення до ОП.
Таблиця Сторінок може зберігатися в будь-якому місці фізичної памяті і визначається це ОС.
Процесор використовує виділений регістр (1 з системних регістрів (регістр таблиці сторінок) для збереження базового адресу сторінки)
											ЗАГАЛЬНА СТРУКТУРА НАВЧАЛЬНОЇ ЕОМ
ДИВ загальна структура навчальної ЕОМ.png
навчальна ЕОМ включає в себе оперативну память, кеш, пристрої введення виведення, процесор складається з пристрою управління, арифметикологічного пристрою і регістрів.
В комірках ОП зберігаються команди та дані. Ємність - 1000комірок.
По сигналу M wr(memory write) виконуэться запис вмістимого регістра даних MDR в комірку вказану в регістрі MAR.
M rd (memory read) виконується зчитування за адресом що знаходиться в регістрі MAR в MDR.
кеш память складається з 10 регістрів загального призначення R0 - R9.
доступ здійснюються через RAR i RDR
ALU здійснює виконання арифметичних операцій визначених кодом операцій COP
операція здійснюється над регістром акомулятора ACC та регістра операнда DR.
результат операції зберігається в регістрі ACC.
при завершенні виконання операції ALU виробляє наступні признаки результату 
признак Z = 1 якщо результат = 0
признак S = 1 якщо результат <0
признак OV = 1 при переповненні розрядної сітки
в ЕОМ передбачені зовнішні пристрої 2 типів 
1. регістри IR OR які обмінюються з акомулятором інформацією за допомогою безадресних команд IN OUT
2. моделюэмі зовнішні пристрої які підключаються до системи у відповідності закладеними моделі алгоритмами.
вони мають ряд програмно доступних регістрів. Блок управління здійснює вибірку команд з ОП в  послідовності визначеній природним порядком виконання команд (в порядку зростання )
або командами передачі управління.
В якості кеш памяті - регістри загального призначення.
в склад процесора входять такі регістри :
PC(program counter) - вміщує в собі адрес текучої команди,CR(IR Comand Register Instruction register) - вміщує в себе код команди
RB(register base ) - регістр базового адресу
SP(steck pointer) - вказівник стеку
RA(register adress) - при непрямій адресації
											представлення даних в моделі
дані представляються в 10 цілі числа.
			система команд
будемо розглядати формати команд способи адресації і систему операцій.
			Формати команд
більшість команд є одноадресними або безадресними довжиною в одне машинне слово 6 розрядів.
Виключення складають двослівні команди з безпосередньою адресацією і команда MOV 
ADR - адрес операнда в памяты 
ADC - 
X - розряд не використовується

					способи адресацій
пряма непряма 
безпосередня 
відносна і безадресна
					система операцій
1. АЛО 
2. Пересилки і завантаження (читання запис пересилка в регістр в стек...)
3. І/О
4. передачі управління безумовний і 6 умовних переходів, виклик підпрограми повернення підпрограми, цикл , програмне переривання
5. порожня операція заборона переривання дозвіл на переривання
								підсистема перериваннь
в нашій моделюємій ЕОМ передбачений механізм векторних зовнішніх переривань.
зовнішні пристрої формують запити на переривання які поступають на входи контроллера переривань.
При підключенні зовнішнього пристрою який здатен формувати запит на переривання йому ставиться у відповідність номер входу контроллера переривань.
цей номер називається вектор переривань приймаючий значення від 0 - 9 у нашому випадку.
Контроллер передає вектор який відповідає запиту процесору який починає процедуру обслуговування переривання.
кожному перериваню повинен відповідати оброблювач переривання це підпрограма яка виконується при виникненні події конкретного переривання.
Механізм перериваннь підтримує таблицю векторів переривань.
Таблиця створюється ОС в ОП.
Номер рядка таблиці відповідає вектору переривання а елемент таблиці - комірка памяті в якій розміщається адрес підпрограми яка обслуговує переривання за цим вектором.
ДИВ таблиця векторів переривань.png
таблиця переривань в нашому випадку чітко фіксована і займає з 100 комірки по 109.
Адрес оброблювача з вектором 0 розміщується в 100 комірці тому комірки з 100 по 109 не рекомендується використовувати підчас програмування.
				алгоритм переривання
процесор починає обробку переривання якщо йому дозволено завершивши текучу команду:
1. отримає від контроллера вектор переривання
2. формує і розміщує у верхушку стека слово 3 4 5 розряд це текуче значення лічильника команд PC це буде адрес повернення до тої команди програми на якій зупинилися
а розряди 1 2 зберігають десятковий еквівалент шістнадцяткової цифри що визначає значення вектора прапорців.
3. скидає в нуль прапорець дозволу на переривання І. І=0. переривання в перериванні не може бути.
4. вибирає з таблиці векторів переривань адрес оброблювача що відповідає вектору і розміщує його в PC і здійснюються таким чином перехід на підпрограму оброблювача переривань.
Виклик оброблювача переривань на відміну від виклику підпрограми звязаний з розміщенням в стек не тільки адресу повернення але й текучого значення вектора прапорців.
тому останньою командою оброблювача повиння бути IRET яка повертає не тільки лічильник команд ай значення прапорців.
команда RET повертає тільки значення лічильника команд.
Якшо прапорець І = 0 то процесор не реагує на запити переривання для того щоб дозволити переривання треба виконати команду ENABLE INTERRUPT.
HLT - ЗУПИНКА


ПРАКТИЧНА 2
IN
WR R1
MUL R1
MUL R1
MUL #10

WR R2

RD R1
MUL R1
MUL #5
ADD #10
ADD R2

WR R2

RD R1
MUL R1
MUL #5
WR R3

RD #15
MUL R1
ADD R3
WR R1

RD R2
DIV R1
OUT
HLT

ПРАКТИЧНА 3 
IN
WR R0
SUB #10

JNS M1
JZ M1

RD R0
MUL R0
MUL R0
MUL #2
WR R1

RD R0
MUL R0
WR R2

RD #30
MUL R0
ADD R2
ADD R1
WR R1
MUL R1
WR R1

RD R0
MUL #2
ADD #3
WR R2
MUL R2
MUL R2
ADD R1
OUT
HLT

M1:
RD R0
MUL R0
MUL R0
MUL R0
WR R1

RD R0
MUL R0
MUL R0
WR R2

RD R0
MUL R0
MUL #10

ADD R1
ADD R2
SUB #5
WR R1
RD #20
ADD R0
WR R0

RD R1
DIV R0
OUT
HLT
