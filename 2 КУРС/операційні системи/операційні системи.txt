Починає виконуватись заново…………



Планування процесів і потоків!



Цитати вчителя:
Для того щоб виконувати процесів потоки в системі ми не можемо їх виконувати хаотично. У нас повинно бути щось сплановано, який потім буде виконуватись наступним. Для цього у нас існує планування. 

Потоки можна зобразити як цикл чергування переодів обчислень ( використання процесора ) і  періодів очікувань виведення - введення. 

Інтервал часу впродовж якого потік виконує команди процесора називають інтервалом виконання процесора. ( CPU BURTH ) 

Інтевал часу коли потік очікує введення виведення називають інтервалом введення-виведення ( input/outup) 
Ці інтевали мають довжину від 2 до 8 мілісекунд.

Частина  операційної системи яка відповідає за політику планувння - називається планувальником. ( scheduler ) 
Алгоритм який використовують для цього - називають алгоритмом планування. ( scheduling algoritm )

Критерії оцінки політики планування:

Мінімальний час відгуку. Це є час між запуском потоку ( введення користувачем команди ) і отримання першої відповіді. 
Для сучасник системи вважають це час від 50 до 150 мілісікунд. 

2. Максимальна пропускна здатність. Кількість задач яка система може виконувати за одиницю часу. Щоб підвищити пропускну здатніть необхідно: 
скорочувати час даремного навантаження; ( наприклад, час потрібен для перемикання контексту)
Ефективніше використовувати ресурси; ( пристрої введення - виведення не повинні простоювати) 
Справидливіть ( заключається, що процесорний час, потокам, виділяють відповідно до їхньої можливості. ) 
Реаліція справидливої політики, не завжди призводить до зменшення середнього часу відгуку. 

Види планування:
1.довготермінове планування. засоби довготермінового планування визначають яку з програм треба завантажити в память для виконання таке планування називають статичним
такий вид планування грунтується на психології користувачів
2.середньотермінове планування. засоби керують переходом потоків з призупиненого стану в стан готовності і назад
потоки готові до виконання організовуються в памяті в структуру яку називають чергою готових потоків.перехід в призупинений стан
можуть викликати такі фактори:
2.1 очікування операції введення виведення
2.2 очікування виконання іношого потоку
2.3 блокування потоку через необхідність синхронізації з іншим потоком
кожна черга пов'язана також з ресурсом який може викликати очікування потоку(з пристроя введення виведення)
такі черги називають чергами планування wait queues
програма середньотермінового планувальника керує всіма цими чергами переміщаючи потоки між ними та чергою готових потоків
3. короткотермінове планування або планування процесора(cpu scheduling)
відповідає на два питання 1.коли перервати виконання потоку 2.якому потокові потрібно передати процесор в цей момент 
програма це підсистема ОС яка в разі необхідності перериває активний потік і вибтрає з черги готових потоків той шо має виконуватись
до цієї програми ставлять найвищі вимоги до продуктивності тому що він отримує керування дуже часто
виділяють з цієї підсистеми програму диспечер (dispatcher)
він безпосередньо передає керування вибраному потокові(перемикає контекст)

            алгоритми планування:
1. Планування за принципом FIFO first input first output (тільки для короткотермінового планування)
потоки ставлять до виконання в порядку їх появи в системі і виконують до переходу в стан очікування, явної передачі керування або завершення
чергу готових потоків організовують за принципом FIFO
як тільки в системі створюється новий потік він додається в хвіст черги. коли процесор звільнюється, то йому надається потік з голови черги
2. кругове планування найпросітш для розуміння є алгоритм кругового планування round-robin scheduling
кожному потоку виділяють інтервал часу квант і в продовж цього часу поток дозволено виконувати
коли потік все ще виконується після вичерпння кванту його переривають і перемикають процесор для виконування команд іншого потоку
коли потік блокується або закінчує своє виконання до вичерпання кванта процесор теж передають іншому потокові
довжина кванту часу для всієї системи однакова. черга готових потоків має бути циклічним списком.
коли потік вичерпав квант часу його переміщають в кінець списку, туди ж додають нові потоки
перевірку кванту часу виконують в обробникому переривання системного таймера
єдина х-ка яка впливає на роботу алгоритму є довжина кванту часу. якщо задання короткого кванту часу призводить до того що відбувається дуже багато перемикань контексту
і процесорний час витрачається не на корисну роботу
якщо довжина кванту велика то це заощаджує процесорний час але зпричиняє зниження часу відгуку на запити
на практиці рекомендують встановлювати довжину кванту від 10 до 100 мілісекунд
3. планування з приорітетами
кругове планування припускає що всі потоки однаково важливі. В іншому разі треба використовувати планування з приорітетами
основна ідеє в наступному: кожному потокові надають приорітет при цьому на виконання ставиться потік з найвищим приорітетом
приорітет може надаватись потоку статично або динамічно. одним з підходів такого планування є алгоритм багаторівневих черг
multilevel queues
в цьому разі ми маємо кілька черг для груп потоків з різними приорітетами. Потоки кожної групи мають різне призначення
4.Планування на підставі характеристик подальшого виконання
Важливим класом алгоритмів планування з приорітетами є алгоритми в яких рішення про вибір потоку для виконання приймають на підставі знання або оцінку характеристик подальшого його виконання
4.1 shortest time of complectition 
цей алгоритм полягає в наступному: з кожним потоком повязують тривалість наступного інтервалу виконання процесора і вибирають потік у якого цей інтервал найкоротший
В результаті потоки що захоплюють процесор на короткий час отримують перевагу і швидше виходять з системи.
            синхронізація потоків
взаємодія потоків 
потоки які виконуються в рамках процесу паралельно можуть взаємодіяти між собою або бути незалежними. Потік є не залежним якшо він не впливає на інші потоки процесу,
немає з ними спільних даних і не зазнає впливу з їхнього боку. Виконання залежить від вхідних даних - детермінований потік
Залежні потоки мають спільні дані залежать від виконання інших потоків і такі потоки називають недетерміновані.
Дані які є загальними для кількох потоків називають спільновикористовуваними даними shared data.
будь який потік в будь який потік часу може змінити ці дані. Механізми забезпечення коректного доступу до цих даних називають !!!механізмами синхронізації потоків!!!
Принципи взаємодії потоків:
1.необхідно організувати спільне використання інформації підчас роботи з потоками наприклад користувачі бази даних можуть одночасно захотіти виконати запити на 
виконання однієї і тієї самої інформації і система має забезпечити паралельне отримання потоками.
2.коректна реалізації такої взаємодії та використання відповідних алгоритмів можуть прискорити обчислювальний процес на багатопроцесорних системах, При цьому задачі
розділяють на підзадачі і виконують на різних процесорах а потім результати збирають разом для рішення
таку технологію називають технологія паралельних обчислень
3.В задачах які вимагають паралельного обчислення та операцій введення/виведення потоки що виконують введення/виведення повинні мати можливість подавати сигнали потокам 
які виконують обчислення
4.задача розбивається на окремі виконувані модулі оформлені як потоки. Вихід одного модуля може бути входом до іншого цим самим підвищується гнучкість системи
Проблеми взаємодії потоків:
1.проблема змагання
в банку для обслуговування кожного користувача виділяють окремий потік для підвищення продуктивності системи при великій кількості одночасних запитів.
Для збільшення вкладу користувача нам треба збільшити величину глбальної змінної, чи можна дати гарантію що в наслідок роботи з вкладом потік який відповідає кожному користувач
буде здатний збільшити значення на потрібну величину?
розпишемо дану дію на кілька:
1. отримання поточного значення тотал емаунт з памяті
2.збільшуємо його на величину ню емаунт і збережемо результат памяті.
Результат виконання коду залежить від послідовності виконання потоків у системі
в одній працює в іншій ні і передбачити помилку не можливо, таку ситуацію називають проблемою змагання рейс кондішн. Це найскладніша проблема. не реально перебрати 
всі можливі комбінаціії виконання потоків тому є необхідність синхронізації потоків. Організація паралельних обчислень і проблеми синхронізацїї є одними з найскладніших проблем
практичного програмування.
Для багатопотокових систем традиційне налагодження не придатне. На етапі розробки програми не можна залишати місце для помилок синхронізації.
Підходи до розвязання проблеми змагань:
іноді можна просто ігнорувати такі помилки, коли нас не цікавить точна реєстрація таких даних наприклад глобальним лічильником є величина на базі якої розраховують середню
к-сть запитів і можна проігнорувати помилки кількості таких запитів.
2.Використання глобальних змінних не диктується специфікою задачі в цьому випадку єстворення локальних копій цих даних працює досить добре наприкла
задача допускає створення окремого лічильника для кожного потоку(глобального масиву лічильників де кожен елемент змінюється тільки певним потоком).така організація також вирішує
проблему змагань. в іншому випадку потрібно забезпечити захист змін від впливу інших потоків це і є основним завданням синхронізації.
                  критичні секції та блокування